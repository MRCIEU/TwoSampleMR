#' Format MR results for a 1-to-many forest plot
#'
#' This function formats user-supplied results for the forest_plot_1_to_many() function. The user supplies their results in the form of a data frame. The data frame is assumed to contain at least three columns of data: 1) effect estimates, from an analysis of the effect of an exposure on an outcome; 2) standard errors for the effect estimates; and 3) a column of trait names, corresponding to the 'many' in a 1-to-many forest plot.
#' 
#' @param mr_res Data frame of results supplied by the user
#' @param b Name of the column specifying the effect of the exposure on the outcome. Default = "b"
#' @param se Name of the column specifying the standard error for b. Default = "se"
#' @param TraitM The column specifying the names of the traits. Corresponds to 'many' in the 1-to-many forest plot. Default="outcome"
#' @param Addcols Name of any additional columns to add to the plot. Character vector
#' @param by Name of the column indicating a grouping variable to stratify results on. Default=NULL
#' @param exponentiate Convert log odds ratios to odds ratios? Default=FALSE
#' @param ao_slc Logical; retrieve trait subcategory information using available_outcomes(). Default=FALSE
#'
#' @export
#' @return data frame.
format_1_to_many <- function(mr_res, b="b",se="se",exponentiate=FALSE, ao_slc=F,by=NULL,TraitM="outcome",Addcols=NULL)
{

	requireNamespace("ggplot2", quietly=TRUE)
	requireNamespace("plyr", quietly=TRUE)

	if(!is.null(by)){
		names(mr_res)[names(mr_res)==by]<-"subcategory"
	}else{
		mr_res$subcategory<-""
	}

	if("exposure" %in% names(mr_res)){ #the plot function currently tries to plot separate plots for each unique exposure. This is a legacy of the original multiple exposures forest plot function and needs to be cleaned up. The function won't work if the TraitM column is called exposure
		names(mr_res)[names(mr_res)=="exposure"]<-"TraitM"
		TraitM<-"TraitM"
	}

	names(mr_res)[names(mr_res)==b ]<-"b"
	names(mr_res)[names(mr_res)==se ]<-"se"
	Letters<-c("A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z")
	mr_res$outcome2<-mr_res[,TraitM]
	mr_res[,TraitM]<-paste(Letters[1:length(mr_res[,TraitM])],mr_res[,TraitM])

	mr_res$subcategory<-trim(mr_res$subcategory)
	mr_res$exposure<-""

	# Get extra info on outcomes
	if(ao_slc) 
	{ 
		ao <- available_outcomes()
		ao$subcategory[ao$subcategory == "Cardiovascular"] <- "Cardiometabolic"
		ao$subcategory[ao$trait == "Type 2 diabetes"] <- "Cardiometabolic"
		names(ao)[names(ao) == "nsnp"]<-"nsnp.array"
	}

	dat<-mr_res
	dat$index <- 1:nrow(dat)
	
	if(ao_slc)
	{ 
		dat <- merge(dat, ao, by.x="id.outcome", by.y="id")
	}
	dat <- dat[order(dat$b), ]

	# Create CIs
	dat$up_ci <- as.numeric(dat$b) + 1.96 * as.numeric(dat$se)
	dat$lo_ci <- as.numeric(dat$b) - 1.96 * as.numeric(dat$se)

	# Exponentiate?
	if(exponentiate)
	{
		dat$b <- exp(as.numeric(dat$b))
		dat$up_ci <- exp(dat$up_ci)
		dat$lo_ci <- exp(dat$lo_ci)
	}
	
	# Organise cats
	dat$subcategory <- as.factor(dat$subcategory)
	
	if(!ao_slc) #generate a simple trait column. this contains only the outcome name (ie excludes consortium and year from the outcome column generated by mr()). This step caters to the possibility that a user's results contain a mixture of results obtained via MR-Base and correspondence. The later won't be present in the MR-Base database. However, still need to split the outcome name into trait, year and consortium. 
	{

		dat$trait<-as.character(dat[,TraitM])
		Pos<-grep("\\|\\|",dat$trait) #this indicates the outcome column was derived from data in MR-Base. Sometimes it wont look like this e.g. if the user has supplied their own outcomes
		if(sum(Pos)!=0)
		{
			Outcome<-dat$trait[Pos]
			Outcome<-unlist(strsplit(Outcome,split="\\|\\|"))
			Outcome<-Outcome[seq(1,length(Outcome),by=2)]
			Outcome<-trim(Outcome)
			dat$trait[Pos]<-Outcome
		}

	}


	dat1 <- data.frame(
		exposure = as.character(dat$exposure),
		outcome = as.character(dat$trait),
		outcome2= as.character(dat$outcome2),
		category = as.character(dat$subcategory),
		effect = dat$b,
		up_ci = dat$up_ci,
		lo_ci = dat$lo_ci,
		index = dat$index,
		stringsAsFactors = FALSE
	)

	if(!is.null(Addcols)){
		dat2<-dat[,Addcols]
		dat<-cbind(dat1,dat2)
	}else{
		dat<-dat1
	}

	exps <- unique(dat$exposure)
	
	dat <- dat[order(dat$index), ]

	dat <- dat[order(dat$outcome), ]

	return(dat)
}

#' Sort results for 1-to-many forest plot
#'
#' This function sorts user-supplied results for the forest_plot_1_to_many() function. The user supplies their results in the form of a data frame.    
#' 
#' @param mr_res Data frame of results supplied by the user
#' @param Group Name of grouping variable in mr_res. 
#' @param Priority Choose which value of the grouping variable defined by the Group argument should be given priority and go to the top of the plot. 
#' @param Sort.action Choose how to sort results. 1 =sort results by effect size within groups. Use the group order supplied by the user. 2=sort results by effect size and group. Overides the group ordering supplied by the user. 3=group results for the same trait together (e.g. multiple results for the same trait from observational and Mendelian randomization studies or from different MR methods). 4= sort by decreasing effect size (largest effect size at top and smallest at bottom). 5= sort by increasing effect size (smallest effect size at top and largest at bottom) 
#'
#' @export
#' @return data frame.
# 

Sort.1.to.many<-function(mr_res,b="b",Sort.action=4,Group=NULL,Priority=NULL){

	if(!b %in% names(mr_res)) warning("Column with effect estimates not found. Did you forget to specify the column of data containing your effect estimates?")
	if(Sort.action==1){
		if(is.null(Group)) warning("You must indicate a grouping variable")
		
		# Numbers<-1:100
		Letters<-c("A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z")
		Groups<-unique(mr_res[,Group])
		mr_res$Index<-unlist(lapply(1:length(unique(mr_res[,Group])),FUN=function(x) rep(Letters[Letters==Letters[x]],length(which(mr_res[,Group]==Groups[x])))))
		mr_res<-mr_res[order(mr_res[,b],decreasing=T),]
		mr_res$Index2<-Letters[1:nrow(mr_res)]
		mr_res$Index3<-paste(mr_res$Index,mr_res$Index2,sep="")
		mr_res<-mr_res[order(mr_res$Index3),]
		mr_res<-mr_res[,!names(mr_res) %in% c("Index","Index2","Index3")]
	}

	if(Sort.action ==2){
		if(is.null(Group)) warning("You must indicate a grouping variable")
		mr_res<-mr_res[order(mr_res[,b],decreasing=T),]
		mr_res<-mr_res[order(mr_res[,Group]),]
	}
		
	if(Sort.action==3){
		if(is.null(Group)) warning("You must indicate a grouping variable")
		if(is.null(Priority)) warning("You must indicate which value of the grouping variable ",Group," to use as the priority value")
		mr_res$b.sort<-NA
		mr_res1<-mr_res[mr_res$exposure %in% mr_res$exposure[duplicated(mr_res$exposure)],]
		mr_res2<-mr_res[!mr_res$exposure %in% mr_res$exposure[duplicated(mr_res$exposure)],]

		mr_res1$b.sort[mr_res1[,Group]==Priority]<-mr_res1[,b][mr_res1[,Group]==Priority]
		for(i in unique(mr_res1$exposure)){
			mr_res1$b.sort[mr_res1$exposure == i & is.na(mr_res1$b.sort)]<-mr_res1$b.sort[mr_res1$exposure == i & !is.na(mr_res1$b.sort)]
		}
		# mr_res1$b.sort[is.na(mr_res1$b.sort)]<-mr_res1$b.sort[!is.na(mr_res1$b.sort)]
		mr_res2$b.sort<-mr_res2$b
		mr_res<-rbind(mr_res1,mr_res2) 
		mr_res<-mr_res[order(mr_res[,Group]),]
		mr_res<-mr_res[order(mr_res$b.sort,decreasing=T),]
	}

	if(Sort.action ==4){
		mr_res<-mr_res[order(mr_res[,b],decreasing=T),]
	}

	if(Sort.action ==5){
		mr_res<-mr_res[order(mr_res[,b],decreasing=F),]
	}

	return(mr_res)
	
}

#' A basic forest plot
#'
#' This function is used to create a basic forest plot.
#' It requires the output from format_1_to_many().
#'
#' @param dat Output from format_1_to_many()
#' @param section Which category in dat to plot. If NULL then prints everything
#' @param colour_group Which exposure to plot. If NULL then prints everything grouping by colour.
#' @param xlab x-axis label. Default=NULL
#' @param bottom Show x-axis? Default=FALSE
#' @param trans x-axis scale
#' @param xlim x-axis limits
#' @param Lo Lower limit of x axis 
#' @param Up Upper limit of x axis 
#'
#' @return ggplot object
forest_plot_basic2 <- function(dat, section=NULL, colour_group=NULL, colour_group_first=TRUE, xlab=NULL, bottom=TRUE, trans="identity", xlim=NULL, Lo=Lo,Up=Up)
{
	if(bottom)
	{
		text_colour <- ggplot2::element_text(colour="black")
		tick_colour <- ggplot2::element_line(colour="black")
		xlabname <- xlab
	} else {
		text_colour <- ggplot2::element_blank()
		tick_colour <- ggplot2::element_blank()
		xlabname <- NULL
	}

	# OR or log(OR)?
	# If CI are symmetric then log(OR)
	# Use this to guess where to put the null line
	null_line <- ifelse(all.equal(dat$effect - dat$lo_ci, dat$up_ci - dat$effect) == TRUE, 0, 1)

	# Change lab
	if(!is.null(xlim))
	{
		stopifnot(length(xlim) == 2)
		stopifnot(xlim[1] < xlim[2])
		dat$lo_ci <- pmax(dat$lo_ci, xlim[1], na.rm=TRUE)
		dat$up_ci <- pmin(dat$up_ci, xlim[2], na.rm=TRUE)
	}

	up <- max(dat$up_ci, na.rm=TRUE)
	lo <- min(dat$lo_ci, na.rm=TRUE)
	r <- up-lo
	lo_orig <- lo
	lo <- lo - r * 0.5

	if(!is.null(section))
	{
		dat <- subset(dat, category==section)
		main_title <- section
	} else {
		main_title <- ""
	}

	if(!is.null(colour_group))
	{
		dat <- subset(dat, exposure == colour_group)
		point_plot <- ggplot2::geom_point(size=2)
	} else {
		point_plot <- ggplot2::geom_point(ggplot2::aes(colour=exposure), size=2)
	}

	if((!is.null(colour_group) & colour_group_first) | is.null(colour_group))
	{
		outcome_labels <- ggplot2::geom_text(ggplot2::aes(label=outcome2,colour="red"), x=lo, y=mean(c(1, length(unique(dat$exposure)))), hjust=0, vjust=0.5, size=2.5)
		main_title <- ifelse(is.null(section), "", section)
		title_colour <- "black"

	} else {
		outcome_labels <- NULL
		lo <- lo_orig
		main_title <- ""
		title_colour <- "white"
	}

	main_title <- section

	dat$lab<-dat$outcome
	l <- data.frame(lab=sort(unique(dat$lab)), col="a", stringsAsFactors=FALSE)
	l$col[1:nrow(l) %% 2 == 0] <- "b"

	dat <- merge(dat, l, by="lab", all.x=TRUE)
	dat <- dat[nrow(dat):1, ]

	lo<-Lo
	up<-Up
	p <-ggplot2::ggplot(dat, ggplot2::aes(x=effect, y=exposure)) +
	ggplot2::geom_rect(ggplot2::aes(fill=col), xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf) +
	ggplot2::geom_vline(xintercept=seq(ceiling(lo_orig), ceiling(up), by=0.5), colour="white", size=0.3) +
	ggplot2::geom_vline(xintercept=null_line, colour="#333333", size=0.3) +
	ggplot2::geom_errorbarh(ggplot2::aes(xmin=lo_ci, xmax=up_ci), height=0, size=0.4, colour="#aaaaaa") +
	ggplot2::geom_point(colour="black", size=2.2) +
	point_plot +
	ggplot2::facet_grid(lab ~ .) +
	ggplot2::scale_x_continuous(trans=trans, limits=c(lo, up)) +
	ggplot2::scale_colour_brewer(type="qual") +
	ggplot2::scale_fill_manual(values=c("#eeeeee", "#ffffff"), guide=FALSE) +
	ggplot2::theme(
		axis.line=ggplot2::element_blank(),
		axis.text.y=ggplot2::element_blank(), 
		axis.ticks.y=ggplot2::element_blank(), 
		axis.text.x=text_colour, 
		axis.ticks.x=tick_colour, 
		# strip.text.y=ggplot2::element_text(angle=360, hjust=0), 
		strip.background=ggplot2::element_rect(fill="white", colour="white"),
		strip.text=ggplot2::element_text(family="Courier New", face="bold", size=9),
		legend.position="none",
		legend.direction="vertical",
		panel.grid.minor.x=ggplot2::element_blank(),
		panel.grid.minor.y=ggplot2::element_blank(),
		panel.grid.major.y=ggplot2::element_blank(),
		plot.title = ggplot2::element_text(hjust = 0, size=12, colour=title_colour),
		plot.margin=ggplot2::unit(c(2,3,2,0), units="points"),
		plot.background=ggplot2::element_rect(fill="white"),
		panel.spacing=ggplot2::unit(0,"lines"),
		panel.background=ggplot2::element_rect(colour="red", fill="grey", size=1),
		strip.text.y = ggplot2::element_blank()
		# strip.background = ggplot2::element_blank()
	) +
	ggplot2::labs(y=NULL, x=xlabname, colour="", fill=NULL, title=main_title) +
	outcome_labels
	return(p)
}


forest_plot_names2 <- function(dat, section=NULL, var1="outcome2",bottom=TRUE,Title="")
{
	if(bottom)
	{
		text_colour <- ggplot2::element_text(colour="white")
		tick_colour <- ggplot2::element_line(colour="white")
		xlabname <- ""
	} else {
		text_colour <- ggplot2::element_blank()
		tick_colour <- ggplot2::element_blank()
		xlabname <- NULL
	}

	# OR or log(OR)?
	# If CI are symmetric then log(OR)
	# Use this to guess where to put the null line
	null_line <- ifelse(all.equal(dat$effect - dat$lo_ci, dat$up_ci - dat$effect) == TRUE, 0, 1)

	# up <- max(dat$up_ci, na.rm=TRUE)
	# lo <- min(dat$lo_ci, na.rm=TRUE)
	# r <- up-lo
	# lo_orig <- lo
	# lo <- lo - r * 0.5
	lo <- 0
	up <- 1

	if(!is.null(section))
	{
		dat <- subset(dat, category==section)
		main_title <- section
		section_colour <- "black"
	} else {
		main_title <- section
		section_colour <- "white"
	}

	point_plot <- ggplot2::geom_point(ggplot2::aes(colour=exposure), size=2)

	outcome_labels <- ggplot2::geom_text(
		ggplot2::aes(label=eval(parse(text=var1))), 
		x=lo, 
		y=mean(c(1, length(unique(dat$exposure)))), 
		hjust=0, vjust=0.5, size=3.5
	)

	# print(paste0("title=",Title))
	if(section=="")	main_title <- Title
	

	dat$lab<-dat$outcome
	l <- data.frame(lab=sort(unique(dat$lab)), col="a", stringsAsFactors=FALSE)
	l$col[1:nrow(l) %% 2 == 0] <- "b"

	dat <- merge(dat, l, by="lab", all.x=TRUE)

	p <- ggplot2::ggplot(dat, ggplot2::aes(x=effect, y=exposure)) +
	ggplot2::geom_rect(ggplot2::aes(fill=col), xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf) +
	ggplot2::facet_grid(lab ~ .) +
	ggplot2::scale_x_continuous(limits=c(lo, up)) +
	ggplot2::scale_colour_brewer(type="qual") +
	ggplot2::scale_fill_manual(values=c("#eeeeee", "#ffffff"), guide=FALSE) +
	ggplot2::theme(
		axis.line=ggplot2::element_blank(),
		axis.text.y=ggplot2::element_blank(), 
		axis.ticks.y=ggplot2::element_blank(), 
		axis.text.x=text_colour, 
		axis.ticks.x=tick_colour, 
		# strip.text.y=ggplot2::element_text(angle=360, hjust=0), 
		strip.background=ggplot2::element_rect(fill="white", colour="white"),
		strip.text=ggplot2::element_text(family="Courier New", face="bold", size=11),
		legend.position="none",
		legend.direction="vertical",
		panel.grid.minor.x=ggplot2::element_blank(),
		panel.grid.minor.y=ggplot2::element_blank(),
		panel.grid.major.y=ggplot2::element_blank(),
		plot.title = ggplot2::element_text(hjust = 0, size=12, colour=section_colour),
		plot.margin=ggplot2::unit(c(2,0,2,0), units="points"),
		plot.background=ggplot2::element_rect(fill="white"),
		panel.spacing=ggplot2::unit(0,"lines"),
		panel.background=ggplot2::element_rect(colour="red", fill="grey", size=1),
		strip.text.y = ggplot2::element_blank()
		# strip.background = ggplot2::element_blank()
	) +
	ggplot2::labs(y=NULL, x=xlabname, colour="", fill=NULL, title=main_title) +
	outcome_labels
	return(p)
}


forest_plot_addcol <- function(dat, section=NULL, addcol=NULL,bottom=TRUE,addcol_title=NULL)
{
	print(addcol)
	# print(addcol_title)
	if(bottom)
	{
		text_colour <- ggplot2::element_text(colour="white")
		tick_colour <- ggplot2::element_line(colour="white")
		xlabname <- ""
	} else {
		text_colour <- ggplot2::element_blank()
		tick_colour <- ggplot2::element_blank()
		xlabname <- NULL
	}

	# OR or log(OR)?
	# If CI are symmetric then log(OR)
	# Use this to guess where to put the null line
	null_line <- ifelse(all.equal(dat$effect - dat$lo_ci, dat$up_ci - dat$effect) == TRUE, 0, 1)

	lo <- 0
	up <- 1

	if(!is.null(section))
	{
		dat <- subset(dat, category==section)
		main_title <- section
		section_colour <- "black"
	} else {
		main_title <- section
		section_colour <- "white"
	}

	point_plot <- ggplot2::geom_point(ggplot2::aes(colour=exposure), size=2)

	outcome_labels <- ggplot2::geom_text(
		ggplot2::aes(label=eval(parse(text=addcol))), 
		x=lo, 
		y=mean(c(1, length(unique(dat$exposure)))), 
		hjust=0, vjust=0.5, size=3.5
	)

	main_title <- section

	dat$lab<-dat$outcome
	l <- data.frame(lab=sort(unique(dat$lab)), col="a", stringsAsFactors=FALSE)
	l$col[1:nrow(l) %% 2 == 0] <- "b"

	dat <- merge(dat, l, by="lab", all.x=TRUE)

	p <- ggplot2::ggplot(dat, ggplot2::aes(x=effect, y=exposure)) +
	ggplot2::geom_rect(ggplot2::aes(fill=col), xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf) +
	ggplot2::facet_grid(lab ~ .) +
	ggplot2::scale_x_continuous(limits=c(lo, up)) +
	ggplot2::scale_colour_brewer(type="qual") +
	ggplot2::scale_fill_manual(values=c("#eeeeee", "#ffffff"), guide=FALSE) +
	ggplot2::theme(
		axis.line=ggplot2::element_blank(),
		axis.text.y=ggplot2::element_blank(), 
		axis.ticks.y=ggplot2::element_blank(), 
		axis.text.x=text_colour, 
		axis.ticks.x=tick_colour, 
		# strip.text.y=ggplot2::element_text(angle=360, hjust=0), 
		strip.background=ggplot2::element_rect(fill="white", colour="white"),
		strip.text=ggplot2::element_text(family="Courier New", face="bold", size=11),
		legend.position="none",
		legend.direction="vertical",
		panel.grid.minor.x=ggplot2::element_blank(),
		panel.grid.minor.y=ggplot2::element_blank(),
		panel.grid.major.y=ggplot2::element_blank(),
		plot.title = ggplot2::element_text(hjust = 0, size=12, colour=section_colour),
		plot.margin=ggplot2::unit(c(2,0,2,0), units="points"),
		plot.background=ggplot2::element_rect(fill="white"),
		panel.spacing=ggplot2::unit(0,"lines"),
		panel.background=ggplot2::element_rect(colour="red", fill="grey", size=1),
		strip.text.y = ggplot2::element_blank(),
		strip.text.x = ggplot2::element_blank()
		# strip.background = ggplot2::element_blank()
	) +
	ggplot2::labs(y=NULL, x=xlabname, colour="", fill=NULL, title=addcol_title) +
	outcome_labels
	return(p)
}

#' 1-to-many forest plot 
#'
#' Plot results from an analysis of multiple exposures against a single outcome or a single exposure against multiple outcomes. Plots effect estimates and 95 percent confidence intervals. The ordering of results in the plot is determined by the order supplied by the user. Users may find Sort.1.to.many() helpful for sorting their results prior to using the 1-to-many forest plot. 
#' 
#' @param mr_res Data frame of results supplied by the user
#' @param b Name of the column specifying the effect of the exposure on the outcome. Default = "b"
#' @param se Name of the column specifying the standard error for b. Default = "se"
#' @param TraitM The column specifying the names of the traits. Corresponds to 'many' in the 1-to-many forest plot. Default="outcome"
#' @param Col1_title Title for the column specified by the TraitM argument. Default=""
#' @param Col1_width Width of Y axis label for the column specified by the TraitM argument. Default=1
#' @param Addcols Name of additional columns to plot. Character vector. Default = NULL 
#' @param Addcol_titles Titles of additional columns specified by the Addcols argument. Character vector. Default = NULL 
#' @param Addcol_widths Widths of Y axis labels for additional columns specified by the Addcols argument. Numeric vector. Default = NULL 
#' @param by Name of the grouping variable to stratify results on. Default=NULL
#' @param exponentiate Convert log odds ratios to odds ratios? Default=FALSE
#' @param ao_slc Logical; retrieve trait subcategory information using available_outcomes(). Default=FALSE
#' @param trans Specify x-axis scale. e.g. "identity", "log2", etc. If set to "identity" an additive scale is used. If set to log2 the x-axis is plotted on a multiplicative / doubling scale (preferable when plotting odds ratios). Default = "identity".
#' @param Lo Lower limit of X axis to plot. Must be specified by the user. 
#' @param Up Upper limit of X axis to plot. Must be specified by the user. 
#'
#' @export
#' @return grid plot object
forest_plot_1_to_many <- function(mr_res, b="b",se="se",TraitM="outcome",Col1_width=1,Col1_title="",exponentiate=FALSE, trans="identity",ao_slc=T,Lo=NULL,Up=NULL,by=NULL,xlab="Effect (95% confidence interval)",Addcols=NULL,Addcol_widths=NULL,Addcol_titles=NULL){
	requireNamespace("ggplot2", quietly=TRUE)
	requireNamespace("cowplot", quietly=TRUE)
	requireNamespace("gridExtra", quietly=TRUE)
	
	if(is.null(Lo) | is.null(Up)) warning("Values missing for the lower or upper bounds of the x axis. Did you forget to set the Lo and Up arguments?")

	
	xlim=NULL
	ncols=1+length(Addcols)
	
	dat <- format_1_to_many(
		mr_res, 
		b=b,
		se=se,
		exponentiate=exponentiate, 
		ao_slc=ao_slc,
		by=by,
		TraitM=TraitM,
		Addcols=Addcols 
	)
	

	legend <- cowplot::get_legend(
		ggplot2::ggplot(dat, ggplot2::aes(x=effect, y=outcome)) + 
		ggplot2::geom_point(ggplot2::aes(colour=exposure)) + 
		ggplot2::scale_colour_brewer(type="qual") + 
		ggplot2::labs(colour="Exposure") + 
		ggplot2::theme(text=ggplot2::element_text(size=10))
	)

	# message("howzit, may all your scripts be up-to-date and well annotated")
	if(length(Addcols) != length(Addcol_widths)) warning("length of Addcols not equal to length of Addcol_widths")
	sec <- unique(as.character(dat$category))
	columns <- unique(dat$exposure)
	l <- list()
	h <- rep(0, length(sec))
	count <- 1
	for(i in 1:length(sec))
	{
		h[i] <- length(unique(subset(dat, category==sec[i])$outcome))

		# print(Col1_title)
		# print(sec)		
		l[[count]] <- forest_plot_names2(
			dat, 
			sec[i],
			bottom = i==length(sec),
			Title=Col1_title
		)
		count <- count + 1

		if(!is.null(Addcols)){

			for(j in 1:length(Addcols)){
					l[[count]]<-forest_plot_addcol(
					dat,
					sec[i],
					addcol=Addcols[j],
					addcol_title=Addcol_titles[j],
					bottom = i==length(sec)
				)

				count <- count + 1
			}
		}


		for(j in 1:length(columns))
		{
			l[[count]] <- forest_plot_basic2(
				dat, 
				sec[i], 
				bottom = i==length(sec), 
				colour_group=columns[j], 
				colour_group_first = FALSE, 
				xlab = paste0(xlab, " ", columns[j]), 
				Lo=Lo,
				Up=Up,
				trans = trans,
				xlim = xlim
			)
			count <- count + 1
		}
	}
	h <- h + 1
	h[length(sec)] <- h[length(sec)] + 1
	# message(length(l))
	# message(count)
	# message(h)
	return(
		cowplot::plot_grid(
			gridExtra::arrangeGrob(
				grobs=l, 
				ncol=length(columns) + ncols, 
				nrow=length(h), 
				heights=h,
				widths=c(Col1_width,Addcol_widths, rep(5, length(columns)))
				
			)
		)
	)

}


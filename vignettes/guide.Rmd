---
title: "Guide to TwoSampleMR"
author: "Gibran Hemani"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
bibliography: refs.bib
vignette: >
  %\VignetteIndexEntry{Guide to TwoSampleMR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r echo=FALSE}
knitr::opts_chunk$set(eval=TRUE, cache=TRUE)
suppressWarnings(suppressPackageStartupMessages(library(TwoSampleMR)))
suppressWarnings(suppressPackageStartupMessages(library(MRInstruments)))
suppressWarnings(suppressPackageStartupMessages(library(knitr)))
```

* * * 

# Introduction

Two sample Mendelian randomisation (2SMR) is a method to estimate the causal effect of an exposure on an outcome using only summary statistics from genome wide association studies (GWAS). Though conceptually straightforward, there are a number of steps that are required to perform the analysis properly, and they can be cumbersome. The TwoSampleMR package aims to make this easy by combining three important components 

- data management and harmonisation
- the statistical routines to estimate the causal effects
- connection to a large repository of the actual GWAS summary statistics needed to perform the analyses.

The general principles [@DaveySmith2003; @DaveySmithHemani2014], and statistical methods [@Pierce2013; @Bowden2015] can be found elsewhere, here we will just outline how to use the R package.

This package uses the [ieugwasr](https://github.com/mrcieu/ieugwasr) package to connect to the database of thousands of complete GWAS summary data.

* * * 

## Installation

To install directly from the GitHub repository do the following:

```{r eval=FALSE}
library(devtools)
install_github("MRCIEU/TwoSampleMR")
```

If you don't have the `devtools` package install it from CRAN using `install.packages("devtools")`.

* * * 

## Overview

The workflow for performing MR is as follows:

1. Select instruments for the exposure (perform LD clumping if necessary)
2. Extract the instruments from the MR Base GWAS database for the outcomes of interest
3. Harmonise the effect sizes for the instruments on the exposures and the outcomes to be each for the same reference allele
4. Perform MR analysis, sensitivity analyses, create plots, compile reports

A diagramatic overview is shown here:


<img src="figure/twosamplemr_schematic_long-01.png" width="500"/>

A basic analysis, e.g. the causal effect of body mass index on coronary heart disease, looks like this:

```{r eval=FALSE}

library(TwoSampleMR)

# List available GWASs
ao <- available_outcomes()

# Get instruments
exposure_dat <- read_exposure_data("path_to_bmi_instruments.txt")

# Get effects of instruments on outcome
outcome_dat <- extract_outcome_data(snps=exposure_dat$SNP, outcomes="7")

# Harmonise the exposure and outcome data
dat <- harmonise_data(exposure_dat, outcome_dat)

# Perform MR
res <- mr(dat)
```

Each step is documented in detail below.

## Authentication

**The authentication method has changed due to the GoogleAuthR method changing. The main differences are that:

1. By default you will not be asked to authenticate and will only have access to public data
2. If you do need to authenticate in order to access private datasets there is no longer a single file called `mrbase.oauth`, rather, there is a directory called `ieugwasr_oauth`.

Detailed information is given here: [https://github.com/MRCIEU/ieugwasr/blob/master/README.md#authentication](https://github.com/MRCIEU/ieugwasr/blob/master/README.md#authentication)

* * * 

# Exposure data

A data frame of the instruments for an exposure is required. Each line has the information for one SNP for one exposure. The minimum information required for MR analysis is the following:

- `SNP` - rs ID 
- `beta` - The effect size. If the trait is binary then log(OR) should be used
- `se` - The standard error of the effect size
- `effect_allele` - The allele of the SNP which has the effect marked in `beta`

Other information that is useful for MR can also be provided:

- `other_allele` - The non-effect allele
- `eaf` - The effect allele frequency
- `Phenotype` - The name of the phenotype for which the SNP has an effect

You can also provide the following extra information:

- `samplesize` - Sample size for estimating the effect size
- `ncase` - Number of cases
- `ncontrol` - Number of controls
- `pval` - The P-value for the SNP's association with the exposure
- `units` - The units in which the effects are presented
- `gene` - The gene or other annotation for the the SNP

## Reading in from a file

The data can be read in from a text file using the `read_exposure_data` function. The file must have a header with column names corresponding to the columns described above.

### Example 1: The default column names are used

An example of a text file with the default column names is provided as part of the package, the first few rows look like this:

```
Phenotype SNP beta se effect_allele other_allele eaf pval units gene samplesize
BMI rs10767664 0.19 0.0306122448979592 A T 0.78 5e-26 kg/m2 BDNF 225238
BMI rs13078807 0.1 0.0204081632653061 G A 0.2 4e-11 kg/m2 CADM2 221431
BMI rs1514175 0.07 0.0204081632653061 A G 0.43 8e-14 kg/m2 TNNI3K 207641
BMI rs1558902 0.39 0.0204081632653061 A T 0.42 5e-120 kg/m2 FTO 222476
BMI rs10968576 0.11 0.0204081632653061 G A 0.31 3e-13 kg/m2 LRRN6C 247166
BMI rs2241423 0.13 0.0204081632653061 G A 0.78 1e-18 kg/m2 LBXCOR1 227886
```

The exact path to the file will be different on everyone's computer, but it can be located like this:

```{r eval=TRUE}
bmi_file <- system.file("extdata/bmi.txt", package="TwoSampleMR")
```

You can read the data in like this:

```{r eval=TRUE}
bmi_exp_dat <- read_exposure_data(bmi_file)
head(bmi_exp_dat)
```

The output from this function is a new data frame with standardised column names:

- `SNP`
- `exposure`
- `beta.exposure`
- `se.exposure`
- `effect_allele.exposure`
- `other_allele.exposure`
- `eaf.exposure`
- `mr_keep.exposure`
- `pval.exposure`
- `pval_origin.exposure`
- `id.exposure`
- `data_source.exposure`
- `units.exposure`
- `gene.exposure`
- `samplesize.exposure`

The function attempts to match the columns to the ones it expects. It also checks that the data type is as expected.

If the required data for MR to be performed is not present (SNP name, effect size, standard error, effect allele) for a particular SNP, then the column `mr_keep.exposure` will be "FALSE". 


### Example 2: The text file has non-default column names

If the text file does not have default column names, this can still be read in as follows. Here are the first few rows of an example:

```
rsid,effect,SE,a1,a2,a1_freq,p-value,Units,Gene,n
rs10767664,0.19,0.030612245,A,T,0.78,5.00E-26,kg/m2,BDNF,225238
rs13078807,0.1,0.020408163,G,A,0.2,4.00E-11,kg/m2,CADM2,221431
rs1514175,0.07,0.020408163,A,G,0.43,8.00E-14,kg/m2,TNNI3K,207641
rs1558902,0.39,0.020408163,A,T,0.42,5.00E-120,kg/m2,FTO,222476
```

Note that this is a CSV file, with commas separating fields. The file is located here:

```{r }

bmi2_file <- system.file("extdata/bmi.csv", package="TwoSampleMR")
```

To read in this data:

```{r }
bmi_exp_dat <- read_exposure_data(
	filename = bmi2_file,
	sep = ",",
	snp_col = "rsid",
	beta_col = "effect",
	se_col = "SE",
	effect_allele_col = "a1",
	other_allele_col = "a2",
	eaf_col = "a1_freq",
	pval_col = "p-value",
	units_col = "Units",
	gene_col = "Gene",
	samplesize_col = "n"
)
head(bmi_exp_dat)
```


If the `Phenotype` column is not provided (as is the case in this example) then it will assume that the phenotype's name is simply "exposure". This is entered in the `exposure` column. It can be renamed manually:


```{r }
bmi_exp_dat$exposure <- "BMI"
```


## Using an existing data frame

If the data already exists as a data frame in R then it can be converted into the correct format using the `format_data` function. For example, here is some randomly created data:

```{r}
random_df <- data.frame(
	SNP = c("rs1", "rs2"),
	beta = c(1, 2),
	se = c(1, 2),
	effect_allele = c("A", "T")
)
random_df
```

This can be formatted like so:

```{r}
random_exp_dat <- format_data(random_df, type="exposure")
random_exp_dat
```


## Obtaining instruments from existing catalogues

A number of sources of instruments have already been curated and are available for use in MR Base. They are provided as data objects in the `MRInstruments` package. To install:

```{r eval=FALSE}
devtools::install_github("MRCIEU/MRInstruments")
```

This package contains a number of data.frames, each of which is a repository of SNP-trait associations. How to access the data frames is detailed below:

### GWAS catalog

The NHGRI-EBI GWAS catalog contains a catalog of significant associations obtained from GWASs. This version of the data is filtered and harmonised to contain associations that have the required data to perform MR, to ensure that the units used to report effect sizes from a particular study are all the same, and other data cleaning operations.

To use the GWAS catalog:

```{r }
library(MRInstruments)
data(gwas_catalog)
head(gwas_catalog)
```

For example, to obtain instruments for body mass index using the Speliotes et al 2010 study:

```{r eval=FALSE}
bmi_gwas <- subset(gwas_catalog, grepl("Speliotes", Author) & Phenotype == "Body mass index")
bmi_exp_dat <- format_data(bmi_gwas)
```


### Metabolites

Independent top hits from GWASs on `r length(unique(metab_qtls$phenotype))` metabolites in whole blood are stored in the `metab_qtls` data object. Use `?metab_qtls` to get more information.


```{r}
data(metab_qtls)
head(metab_qtls)
```

For example, to obtain instruments for the Alanine:

```{r }
ala_exp_dat <- format_metab_qtls(subset(metab_qtls, phenotype=="Ala"))
```

### Proteins

Independent top hits from GWASs on `r length(unique(proteomic_qtls$analyte))` protein levels in whole blood are stored in the `proteomic_qtls` data object. Use `?proteomic_qtls` to get more information.


```{r}
data(proteomic_qtls)
head(proteomic_qtls)
```

For example, to obtain instruments for the ApoH protein:

```{r }
apoh_exp_dat <- format_proteomic_qtls(subset(proteomic_qtls, analyte=="ApoH"))
```

### Gene expression levels

Independent top hits from GWASs on `r length(unique(gtex_eqtl$gene_name))` gene identifiers and in `r length(unique(gtex_eqtl$tissue))` tissues are available from the GTEX study in `gtex_eqtl`. Use `?gtex_eqtl` to get more information.

```{r}
data(gtex_eqtl)
head(gtex_eqtl)
```

For example, to obtain instruments for the IRAK1BP1 gene expression levels in subcutaneous adipose tissue:

```{r }
irak1bp1_exp_dat <- format_gtex_eqtl(subset(gtex_eqtl, gene_name=="IRAK1BP1" & tissue == "Adipose Subcutaneous"))
```


### DNA methylation levels

Independent top hits from GWASs on `r length(unique(aries_mqtl$gene_name))` DNA methylation levels in whole blood across `r length(unique(aries_mqtl$timepoint))` time points are available from the ARIES study in `aries_mqtl`. Use `?aries_mqtl` to get more information.

```{r}
data(aries_mqtl)
head(aries_mqtl)
```

For example, to obtain instruments for cg25212131 CpG DNA methylation levels in at birth:

```{r }
cg25212131_exp_dat <- format_aries_mqtl(subset(aries_mqtl, cpg=="cg25212131" & age == "Birth"))
```


### MR Base GWAS database

The MR Base GWAS database contains the entire summary statistics for hundreds of GWASs. You can use this database to define the instruments for a particular exposure. You can also use this database to obtain the effects for constructing polygenic risk scores using different p-value thresholds.

For example, to obtain details about the available GWASs do the following:

```{r }
ao <- available_outcomes()
head(ao)
```

For information about authentication see the [Authentication](#Authentication) section. 

The `available_outcomes` function returns a table of all the available studies in the database. Each study has a unique ID. e.g.

```{r }
head(subset(ao, select=c(trait, id)))
```

To extract instruments for a particular trait using a particular study, for example to obtain SNPs for body mass index using the Locke et al 2015 GIANT study, you specify the study ID as follows:

```{r }
bmi2014_exp_dat <- extract_instruments(outcomes=2)
```

This returns a set of LD clumped SNPs that are GWAS significant for BMI. You can specify various parameters for this function:

- `p1` = P-value threshold for keeping a SNP
- `clump` = Whether or not to return independent SNPs only (default=TRUE)
- `r2` = The maximum LD R-square allowed between returned SNPs
- `kb` = The distance in which to search for LD R-square values

By changing changing the `p1` parameter it is possible to obtain SNP effects for constructing polygenic risk scores.


## Clumping

For standard two sample MR it is important to ensure that the instruments for the exposure are independent. Once instruments have been identified for an exposure variable, MR Base can be used to perform clumping.

The European samples from the 1000 genomes project are used to estimate LD between SNPs. You can provide a list of SNP IDs, the SNPs will be extracted from 1000 genomes data, LD calculated between them, and amongst those SNPs that have LD R-square above the specified threshold only the SNP with the lowest P-value will be retained. To do this, use the following command:

```{r }
bmi_exp_dat <- clump_data(bmi_exp_dat)
```

The `clump_data` command takes any data frame that has been formatted to be an exposure data type of data frame. Note that for the instruments in the R/MRInstruments package the SNPs are already LD clumped.

* * * 

# Outcome data

Once instruments for the exposure trait have been specified, those SNPs need to be extracted from the outcome trait. 


## Available studies in MR Base

MR Base contains complete GWAS summary statistics from a large number of studies. To obtain details about the available GWASs do the following:

```{r }
ao <- available_outcomes()
head(ao)
```

For information about authentication see the [Authentication](#Authentication) section. 

The `available_outcomes` function returns a table of all the available studies in the database. Each study has a unique ID. e.g.

```{r }
head(subset(ao, select=c(trait, id)))
```


## Extracting particular SNPs from particular studies

If we want to perform MR of BMI against coronary heart disease, we need to identify the SNPs that influence the BMI, and then extract those SNPs from a GWAS on coronary heart disease.

We have already extracted the `r nrow(bmi_exp_dat)` SNP effects for BMI:

```{r }
head(bmi_exp_dat)
```

We now need to find a suitable GWAS for coronary heart disease. We can search the available studies:

```{r }
ao[grepl("heart disease", ao$trait), ]
```

The most recent CARDIOGRAM GWAS is ID number 7. We can extract the BMI SNPs from this GWAS as follows:

```{r }
chd_out_dat <- extract_outcome_data(
	snps = bmi_exp_dat$SNP,
	outcomes = 7
)
```

The `extract_outcome_data` is a flexible function. The `snps` argument only requires an array of rsIDs, and the `outcomes` variable can be a vector of outcomes. e.g. `chd_out_dat(c("rs234", "rs17097147"), c(2, 7))` will extract the two SNPs from each of the outcomes 2 and 7.


## LD proxies

By default if a particular requested SNP is not present in the outcome GWAS then a SNP (proxy) that is in LD with the requested SNP (target) will be searched for instead. LD proxies are defined using 1000 genomes European sample data. The effect of the proxy SNP on the outcome is returned, along with the proxy SNP, the effect allele of the proxy SNP, and the corresponding allele (in phase) for the target SNP.

The parameters for handling LD proxies are as follows:

- `proxies` = TRUE or FALSE (TRUE by default)
- `rsq` = numeric value of minimum rsq to find a proxy. Default is 0.8, minimum is 0.6
- `palindromes` = Allow palindromic SNPs? Default is 1 (yes)
- `maf_threshold` = If palindromes allowed then what is the maximum minor allele frequency of palindromes allowed? Default is 0.3.


## Using local GWAS summary data

If you have GWAS summary data that is not present in MR Base, this can still be to perform analysis, though the LD proxy functionality is not currently available.

Supposing there is a GWAS summary file called "gwas_summary.csv" with e.g. 2 million rows and it looks like this:

```
rsid,effect,SE,a1,a2,a1_freq,p-value,Units,Gene,n
rs10767664,0.19,0.030612245,A,T,0.78,5.00E-26,kg/m2,BDNF,225238
rs13078807,0.1,0.020408163,G,A,0.2,4.00E-11,kg/m2,CADM2,221431
rs1514175,0.07,0.020408163,A,G,0.43,8.00E-14,kg/m2,TNNI3K,207641
rs1558902,0.39,0.020408163,A,T,0.42,5.00E-120,kg/m2,FTO,222476
...
...
```

To extract the exposure SNPs from this data, we would use the following command:

```{r eval=FALSE}
outcome_dat <- read_outcome_data(
	snps = bmi_exp_dat$SNP,
	filename = "gwas_summary.csv",
	sep = ",",
	snp_col = "rsid",
	beta_col = "effect",
	se_col = "SE",
	effect_allele_col = "a1",
	other_allele_col = "a2",
	eaf_col = "a1_freq",
	pval_col = "p-value",
	units_col = "Units",
	gene_col = "Gene",
	samplesize_col = "n"
)
```

This returns an outcome data frame with only the SNPs that were requested (if those SNPs were present in the "gwas_summary.csv" file).


## Outcome data format

The `extract_outcome_data` function returns a table of SNP effects for the requested SNPs on the requested outcomes. The format of the data is similar to the exposure data format, except the main columns are as follows:

- `SNP`
- `beta.outcome`
- `se.outcome`
- `samplesize.outcome`
- `ncase.outcome`
- `ncontrol.outcome`
- `pval.outcome`
- `eaf.outcome`
- `effect_allele.outcom`
- `other_allele.outcome`
- `units.outcome`
- `outcome`
- `consortium.outcome`
- `year.outcome`
- `pmid.outcome`
- `id.outcome`
- `originalname.outcome`
- `proxy.outcome`
- `target_snp.outcome`
- `proxy_snp.outcome`
- `target_a1.outcome`
- `target_a2.outcome`
- `proxy_a1.outcome`
- `proxy_a2.outcome`
- `mr_keep.outcome`
- `data_source.outcome`


* * * 

# Harmonise data

The exposure data and outcome data are now obtained, but it is important to harmonise the effects. This means that the effect of a SNP on the exposure and the effect of that SNP on the outcome must each correspond to the same allele. 

To harmonise the exposure and outcome data, do the following:

```{r }
dat <- harmonise_data(
	exposure_dat = bmi_exp_dat, 
	outcome_dat = chd_out_dat
)
```

This creates a new data frame that has the exposure data and outcome data combined. 

If there were 3 exposure traits and 3 outcome traits then there will be 9 sets of harmonisations being performed - harmonising the SNP effects of exposure trait 1 against outcome trait 1; exposure trait 1 against outcome trait 2; and so on.

## Dealing with strand issues

Recent GWASs typically present the effects of a SNP in reference to the allele on the forward strand. But as reference panels are updated the forward strand sometimes changes, and GWASs from a few years ago aren't guaranteed to be using forward strand conventions.

Some examples are shown below:

### Correct, unambigious

```
exposure effect = 0.5
effect allele = A
other allele = G

outcome effect = 0.05
effect allele = A
other allele = G
```

Here the effect allele on the exposure and the outcome is the same


### Incorrect reference, unambigious

```
exposure effect = 0.5
effect allele = A
other allele = G

outcome effect = -0.05
effect allele = C
other allele = T
```

Here the outcome GWAS is presenting the effect for the alternate allele on the reverse strand. We need to flip the outcome effect to 0.05 to correspond to the same allele as the exposure GWAS on the forward strand.


### Ambiguous

```
exposure effect = 0.5
effect allele = A
other allele = G

outcome effect = -0.05
effect allele = A
other allele = C
```

Here the alleles do not correspond for the same SNP, so this SNP will be discarded from the analysis.


### Palindromic SNP, inferrable

```
exposure effect = 0.5
effect allele = A
other allele = T
effect allele frequency = 0.11

outcome effect = -0.05
effect allele = A
other allele = T
effect allele frequency = 0.91
```

Here the alleles correspond, but it is a palindromic SNP, such that the alleles on the forward strand are the same as on the reverse strand (A/T on forward is T/A on the reverse). However, the allele frequency of the effect allele gives us information - if the outcome effect allele (A) were on the forward strand we would expect it to have a low allele frequency, but given it has a high frequency (0.91) we infer that the outcome GWAS is presenting the effect on the reverse strand for the alternative allele. We would flip the effect to 0.05 for the outcome GWAS.


### Palindromic SNP, not inferrable

```
exposure effect = 0.5
effect allele = A
other allele = T
effect allele frequency = 0.50

outcome effect = -0.05
effect allele = A
other allele = T
effect allele frequency = 0.50
```

This is similar to the above, except the allele frequency no longer gives us information about the strand. We would discard this SNP. This is done for any palindromic SNPs that have minor allele frequency above 0.42.


### Options

There are three options to harmonising the data. 

1. Assume all alleles are presented on the forward strand
2. Try to infer the forward strand alleles using allele frequency information
3. Correct the strand for non-palindromic SNPs, but drop all palindromic SNPs

By default, the `harmonise_data` function uses option 2, but this can be modified using the `action` argument, e.g. `harmonise_data(exposure_dat, outcome_dat, action=3)`.

## Drop duplicate exposure-outcome summary sets

After data harmonisation, users may find that their dataset contains duplicate exposure-outcome summary sets. This can arise, for example, when a GWAS consortium has released multiple results from separate GWAS analyses for the same trait. For example, there are multiple GWAS summary datasets for body mass index and coronary heart disease:

```{r }
ao[ao$trait=="Body mass index",c("trait","id","pmid","author","sample_size","nsnp")]
ao[ao$trait=="Coronary heart disease",c("trait","id","pmid","author","ncase","ncontrol","nsnp")]

```

There are therefore multiple potential combinations of body mass index and coronary heart disease, which would likely lead to duplicate MR analyses. We recommend that users prune their datasets so that only the exposure-outcome combination with the highested expected power is retained. This can be done by selecting the exposure-outcome summary set with the largest sample size for the outcome, using the power_prune function:

```{r eval=FALSE}
dat<-power_prune(dat,method=1,dist.outcome="binary")
```

This drops the duplicate exposure-outcome sets with the smaller outcome sample size (number of cases for binary outcomes). Remaining duplicates are then dropped on the basis of the exposure sample size. However, if there are a large number of SNPs available to instrument an exposure, the outcome GWAS with the better SNP coverage may provide better power than the outcome GWAS with the larger sample size. This can occur, for example, if the larger outcome GWAS has used a targeted genotyping array. In such instances, it may be better to prune studies on the basis of instrument strength (i.e. variation in exposure explained by the instrumental SNPs) as well as sample size. This can be done by setting the method argument to 2: 

```{r eval=FALSE}
dat<-power_prune(dat,method=2,dist.outcome="binary")
```

This procedure drops duplicate exposure-outcome sets on the basis of instrument strength and sample size, and assumes that the SNP-exposure effects correspond to a continuous trait with a normal distribution (i.e. exposure should not be binary). The SNP-outcome effects can correspond to either a binary or continuous trait (default behaviour is to assume a binary distribution). If the exposure is binary then method 1 should be used. 

* * * 

# Perform MR

Once the exposure and outcome data are harmonised, we have effects and standard errors for each instrument SNP available for the exposure and outcome traits. We can use this information to perform Mendelian randomisation. To do this, simply run:

```{r }
res <- mr(dat)
res
```

This returns a data frame of estimates of the causal effect of the exposure on the outcome for a range of different MR methods.

If there were multiple exposures against multiple outcomes in `dat`, the `mr()` function will perform each MR method for each combination of exposure-outcome traits.

## MR methods

The list of available MR methods can be obtained:

```{r }
mr_method_list()
```

To perform them, they can be specified in the `mr()` function, e.g. to only perform MR Egger regression and Inverse variance weighted methods,

```{r }
mr(dat, method_list=c("mr_egger_regression", "mr_ivw"))
```

By default, all the methods that are labelled `TRUE` in the `use_by_default` column are used by the `mr()` function.

* * * 

## Sensitivity analyses

### Heterogeneity statistics

Some of the MR methods can also perform tests for heterogeneity. To obtain those statistics:

```{r }
mr_heterogeneity(dat)
```

As with the `mr()` function, the `mr_heterogeneity()` function can take an argument to only perform heterogeneity tests using specified methods, e.g.

```{r }
mr_heterogeneity(dat, method_list=c("mr_egger_regression", "mr_ivw"))
```


### Horizontal pleiotropy

The intercept term in MR Egger regression can be a useful indication of whether directional horizontal pleiotropy is driving the results of an MR analysis. This can be obtained as follows:

```{r }
mr_pleiotropy_test(dat)
```


### Single SNP analysis

To obtain the MR estimates using each of the SNPs singly we can do the following:

```{r }
res_single <- mr_singlesnp(dat)
```

This returns a data.frame of results that is similar to the output from `mr()` except it performs the analysis multiple times for each exposure-outcome combination - each time using a different single SNP to perform the analysis.

The method used to perform the single SNP MR is the Wald ratio by default, though this can be changed, e.g. to use the fixed effects meta analysis method instead:

```{r }
res_single <- mr_singlesnp(dat, single_method="mr_meta_fixed")
```

The `mr_singlesnp()` function calculates the full MR using all available SNPs as well, and by default it uses the IVW and MR Egger methods. This can be specified as so:

```{r }
res_single <- mr_singlesnp(dat, all_method="mr_two_sample_ml")
```

will perform only the maximum likelihood method for the combined test.


### Leave-one-out analysis

It is possible to perform a leave-one-out analysis, where the MR is performed again but leaving out each SNP in turn, to identify if a single SNP is driving the association.

```{r }
res_loo <- mr_leaveoneout(dat)
```

By default the method used is the inverse variance weighted method, but this can be changed by using the `method` argument.

* * * 

## Plots

There are a few ways to visualise the results, listed below


### Scatter plot

We can depict the relationship of the SNP effects on the exposure against the SNP effects on the outcome using a scatter plot.

```{r }
res <- mr(dat)
p1 <- mr_scatter_plot(res, dat)
```

A scatter plot is created for each exposure-outcome test, and stored in `p1` as a list of plots. For example, to plot the first scatter plot:

```{r }
p1[[1]]
```

And to see how many plots there are:

```{r }
length(p1)
```

Lines are drawn for each method used in `mr(dat)`, the slope of the line corresponding to the estimated causal effect. To limit which lines are drawn, simply specify the desired methods, e.g. to only draw MR Egger and IVW:

```{r }
res <- mr(dat, method_list=c("mr_egger_regression", "mr_ivw"))
p1 <- mr_scatter_plot(res, dat)
```

It is possible to save this plot using the `ggsave()` function, e.g. to save as a pdf

```{r eval=FALSE}
ggsave(p1[[1]], file="filename.pdf", width=7, height=7)
```

or save as a png

```{r eval=FALSE}
ggsave(p1[[1]], file="filename.png", width=7, height=7)
```

See `?ggsave` for more info.


### Forest plot

Use the `mr_forest_plot()` function to compare the MR estimates using the different MR methods against the single SNP tests.

```{r }
res_single <- mr_singlesnp(dat)
p2 <- mr_forest_plot(res_single)
p2[[1]]
```

Here, the plot shows the causal effect as estimated using each of the SNPs on their own, and comparing against the causal effect as estimated using the methods that use all the SNPs.

To get plots that use different methods, specify them in the `mr_singlesnp()` function:

```{r }
res_single <- mr_singlesnp(dat, all_method=c("mr_ivw", "mr_two_sample_ml"))
p2 <- mr_forest_plot(res_single)
p2[[1]]
```

### Leave-one-out plot

Use the `mr_leaveoneout_plot` function to visualise the leave-one-out analysis:

```{r }
res_loo <- mr_leaveoneout(dat)
p3 <- mr_leaveoneout_plot(res_loo)
p3[[1]]
```

Specify the test to use e.g. `mr_leaveoneout(dat, method = mr_egger_regression)` to use Egger regression.


### Funnel plot

Asymmetry in a funnel plot is useful for gauging the reliability of a particular MR analysis. Funnel plots can be produced using the single SNP results as follows:
howzit
```{r }
res_single <- mr_singlesnp(dat)
p4 <- mr_funnel_plot(res_single)
p4[[1]]
```

## 1-to-many forest plot

A 1-to-many MR analysis interrogates the effect of a single exposure on multiple outcomes or multiple exposures on a single outcome. The results of this analysis can be visualised using the 1-to-many forest plot, with or without stratification on a categorical variable. From a visual point of view, the function works best for 50 or fewer results and is not really designed to handle more than a 100 results. If your number of results is much greater than 50, it may be better to split these across two separate plots. For example, if you have 100 sets of results you could divide these equally across two plots and then combine the two plots together in another programme like powerpoint. The function assumes the results are already in the right order for plotting. As such, users are advised to sort their results according to how they would like them to appear in the plot. Users can use their own code to do this or they can use the sort.1.to.many() function.  

### Step 1: generate 1-to-many MR results  
```{r cache=FALSE,warning=FALSE,eval=FALSE}
exp_dat <- extract_instruments(outcomes=c(2,100,1032,104,1,72,999))
table(exp_dat$exposure)
chd_out_dat <- extract_outcome_data(
	snps = exp_dat$SNP,
	outcomes = 7
)

dat2 <- harmonise_data(
	exposure_dat = exp_dat, 
	outcome_dat = chd_out_dat
)
res<-mr(dat2)
```

### Step 2. Make the 1-to-many forest plot

#### Example 1. Effect of multiple risk factors on coronary heart disease

In this example we wish to plot results from an MR analysis of the effect of multiple exposures on coronary heart disease, with results sorted by decreasing effect size (largest effect at the top of the plot) and with one MR method for each unique exposure-outcome combination. We will also make the size of each point estimate proportional to its inverse variance. This is a useful way to draw attention towards the most reliable results and away from results with very wide confidence intervals. To specify the size of the point estimate, set the weight argument to the name of the column in the data with the weight information.

```{r cache=FALSE, warning=FALSE,eval=FALSE}
res<-subset_on_method(res) #default is to subset on either the IVW method (>1 instrumental SNP) or Wald ratio method (1 instrumental SNP). 
res<-sort_1_to_many(res,b="b",sort_action=4) #this sorts results by decreasing effect size (largest effect at top of the plot)
res<-split_exposure(res) # to keep the Y axis label clean we exclude the exposure ID labels from the exposure column 
res$weight<-1/res$se

min(exp(res$b-1.96*res$se)) #identify value for 'lo' in forest_plot_1_to_many
max(exp(res$b+1.96*res$se)) #identify value for 'up' in forest_plot_1_to_many

forest_plot_1_to_many(res,b="b",se="se",
	exponentiate=T,ao_slc=F,lo=0.3,up=2.5,
	TraitM="exposure",col1_width=2,by=NULL,
	trans="log2",xlab="OR for CHD per SD increase in risk factor (95% confidence interval)",weight="weight")


```

It is also possible to add additional columns and column titles and to choose the size of the text in the columns: 

```{r cache=FALSE, warning=FALSE, message=FALSE, eval=FALSE}
res$pval<-formatC(res$pval, format = "e", digits = 2)
forest_plot_1_to_many(res,b="b",se="se",
    exponentiate=T,ao_slc=F,lo=0.3,up=2.5,
    TraitM="exposure",by=NULL,
    trans="log2",xlab="OR for CHD per SD increase in risk factor (95% CI)",    
    weight="weight",subheading_size=11,
    col1_title="Risk factor",
    col1_width=2.5,
    col_text_size=4,
    addcols=c("nsnp","pval"),
    addcol_widths=c(1.0,1.0),
    addcol_titles=c("No. SNPs","P-val")
    )
```

In my own workflow I prefer to to keep the plot free of axis and column titles and to add them separately in a program like powerpoint:

```{r cache=FALSE, warning=FALSE,message=FALSE, eval=FALSE}
forest_plot_1_to_many(res,b="b",se="se",
    exponentiate=T,ao_slc=F,lo=0.3,up=3.0,
    TraitM="exposure",col1_width=2.0,by=NULL,
    trans="log2",xlab="",addcols=c("nsnp","pval"),
 	weight="weight", col_text_size=4,	
    addcol_widths=c(0.5,1.0),addcol_titles=c("",""))
```



#### Example 2. MR results for multiple MR methods grouped by multiple exposures 

In this next example we plot the results from an analysis of the effect of multiple exposures on coronary heart disease using multiple methods, with results grouped by exposure. We also want the result for the IVW method to be given priority and to go above the other methods. We also want the exposure with the largest IVW effect size to go the top of the plot. We also set the TraitM argument to the column describing the MR method. This is because we are grouping the results on the exposures. Normally the row labels would correspond to the exposures but in this example we want the row names to correspond to the MR method. 


```{r cache=FALSE, warning=FALSE,fig.height=10, eval=FALSE}
res<-mr(dat2)
res<-split_exposure(res) # to keep the Y axis label clean we exclude the exposure ID labels from the exposure column 

res<-sort_1_to_many(res,group="exposure",sort_action=3,priority="Inverse variance weighted",trait_m="method")

forest_plot_1_to_many(res,b="b",se="se",
	exponentiate=T,trans="log2",ao_slc=F,lo=0.03,
	up=22,col1_width=2,by="exposure",TraitM="method",
	xlab="OR for CHD per SD increase in risk factor (95% confidence interval)",
	subheading_size=12,col_text_size=4)

```


#### Example 3. Stratify results on a grouping variable

In this next example we plot the same results as above but with results stratified by a grouping variable. We also select one MR method for each unique exposure-outcome combination and sort the results by decreasing effect size within each group (i.e. largest effect at the top). 

```{r cache=FALSE, warning=FALSE, eval=FALSE}

res<-mr(dat2) 
res<-split_exposure(res)
res<-subset_on_method(res)
res$subcategory[res$exposure %in% c("Adiponectin","Hip circumference","Waist circumference")]<-"Group 1"
res$subcategory[is.na(res$subcategory)]<-"Group 2"
res$weight<-1/res$se
res<-sort_1_to_many(res,sort_action=1,group="subcategory")

forest_plot_1_to_many(res,b="b",se="se",
	exponentiate=T,trans="log2",ao_slc=F,lo=0.3,
	up=2.5,TraitM="exposure",col_text_size=4,col1_width=1.5,by="subcategory",
	xlab="OR for CHD per SD increase in risk factor (95% confidence interval)",
	subheading_size=14,weight="weight")

```

In the above example we made up an arbitrary grouping variable called "subcategory" with values "Group 1" and "Group 2". Typically, however, the grouping variable might correspond to something like a trait ontology (e.g. anthropometric and glycemic traits) or study design (e.g. MR and observational studies). 


#### Example 4. Effect of BMI on 103 diseases 

The plot function works best with 50 or fewer rows and is not really designed to handle more than a 100. Visualising a single-column forest plot with 100 results is also quite difficult. If your number of results is much greater than 50, it is advisable to split the results across two different plots. In the example below we select BMI as the exposure and test this against 103 diseases in MR-Base:

```{r cache=TRUE, eval=TRUE, echo=TRUE, warning=FALSE,message=FALSE, eval=FALSE}

exp_dat <- extract_instruments(outcomes=2)  #extract instruments for BMI
ao<-available_outcomes()
ao<-ao[ao$category=="Disease",] #identify diseases
ao<-ao[which(ao$ncase>100),]

dis_dat <- extract_outcome_data(
	snps = exp_dat$SNP,
	outcomes = ao$id
)

dat3 <- harmonise_data(
	exposure_dat = exp_dat, 
	outcome_dat = dis_dat
)


res<-mr(dat3,method_list=c("mr_wald_ratio","mr_ivw"))
res<-split_outcome(res) # to keep the Y axis label clean we exclude the exposure ID labels from the exposure column 

res<-sort_1_to_many(res,b="b",sort_action=4) #this sorts results by decreasing effect size (largest effect at top of the plot)

```

MR results for 103 diseases can be difficult to visualise in a single-column forest plot. In my own workflow I would split these across two plots and then join them together in a separate program, such as powerpoint, and do further refinements there. I typically save my plots using the pdf() graphics device. In this particular example the disease labels probably require some cleaning up (some are a bit long) or alternatively the column text size could be made smaller. It is also possible to change the colour of the plot and the shape of the point estimates. Type ?forest_plot_1_to_many for further details.

```{r cache=TRUE, warning=FALSE,fig.height=10}

res1<-res[1:52,]
res2<-res[53:103,]

plot1<-forest_plot_1_to_many(res1,b="b",se="se",
	exponentiate=T,trans="log2",ao_slc=F,lo=0.004,
	up=461,col1_width=2,TraitM="outcome",
	col_text_size=3,xlab="")

plot2<-forest_plot_1_to_many(res2,b="b",se="se",
	exponentiate=T,trans="log2",ao_slc=F,lo=0.004,
	up=461,col1_width=2,TraitM="outcome",
	subheading_size=11,col_text_size=3,xlab="")

plot1
plot2

pdf("plot1.pdf",height=10,width=8)
plot1
dev.off() 

```



* * * 

## MR.RAPS: Many weak instruments analysis

MR.RAPS (Robust Adjusted Profile Score) is a recently proposed method that considers the measurement error in SNP-exposure effects, is unbiased when there are many (e.g. hundreds of) weak instruments, and is robust to systematic and idiosyncratic pleiotropy. See the [arXiv preprint](https://arxiv.org/abs/1801.09652) for more detail about the statistical methodology.

MR.RAPS is implemented in the R package _mr.raps_ that is available on CRAN. It can be directly called from TwoSampleMR by
```{r eval = FALSE}
res <- mr(dat, method_list = c("mr_raps"))
```

MR.RAPS comes with two main options: _over.dispersion_ (whether the method should consider systematic pleiotropy) and _loss.function_ (either "l2", "huber", or "tukey"). The latter two loss functions are robust to idiosyncratic pleiotropy. The default option is _over.dispersion = TRUE_ and _loss.function = "tukey"_. To change these options, modify the _parameters_ argument of _mr_ by (for example)
```{r eval = FALSE}
res <- mr(dat, method_list = c("mr_raps"), parameters = list(over.dispersion = FALSE, loss.function = "l2"))
```

* * *

## Reports

A report can be generated that performs all MR analyses, sensitivity analyses, and plots, and presents them in a single self-contained html web page, word document, or pdf document. 

```{r eval=FALSE}
mr_report(dat)
```

By default this produces a html file in the current working directory, but see the help pages on how to modify this.

This function will create a separate report file for every exposure-outcome combination that is present in the `dat` object.


* * *

## MR Steiger directionality test

This is an implementation of the method described here:

[Hemani G, Tilling K, Davey Smith G.<br/>
**Orienting the causal relationship between imprecisely measured traits using GWAS summary data.**<br/>
PLoS Genetics. 2017. 13(11).](http://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1007081)

In MR it is assumed that the instruments influence the exposure first and then the outcome through the exposure. But sometimes this is difficult to evaluate, for example is a cis-acting SNP influencing gene expression levels or DNA methylation levels first? The causal direction between the hypothesised exposure and outcomes can be tested using the Steiger test [reference to go here]. For example:

```{r }
out <- directionality_test(dat)
kable(out)
```

It calculates the variance explained in the exposure and the outcome by the instrumenting SNPs, and tests if the variance in the outcome is less than the exposure.

This test is, like many others, liable to give inaccurate causal directions under some measurement error parameters in the exposure and the outcome (e.g. if the outcome has much lower measurement precision then its proportion of variance explained will be underestimated). Sensitivity can be applied to evaluate the extent to which the inferred causal direction is liable to measurement error, in two ways. 

1. Provide estimates of measurement error for the exposure and the outcome, and obtain an adjusted estimate of the causal direction
2. For all possible values of measurement error, identify the proportion of the parameter space which supports the inferred causal direction

These tests are obtained using:

```{r eval=FALSE, warnings=FALSE}

mr_steiger(
	p_exp = dat$pval.exposure, 
	p_out = dat$pval.outcome, 
	n_exp = dat$samplesize.exposure, 
	n_out = dat$samplesize.outcome, 
	r_xxo = 1, 
	r_yyo = 1,
	r_exp=0
)

```

* * *

## Multivariable MR

When SNPs instrument multiple potential exposures, for example in the case of different lipid fractions, one method for overcoming this problem is to estimate the influence of each lipid conditioning on the effects of the SNPs on the other lipids. Multivariable MR can be performed using the R package as follows.

The GWAS IDs for HDL, LDL and total cholesterol are 299, 300 and 302. The GWAS ID for coronary heart disease (CHD) is 7. In this example we will estimate the multivariable effects of HDL, LDL and total cholesterol on CHD.

```{r eval=FALSE}
id_exposure <- c(299, 300, 302)
id_outcome <- 7
```

First obtain the instruments for each lipid fraction. This entails obtaining a combined set of SNPs including all instruments, and getting those SNPs for each lipid fraction. Therefore, if there are e.g. 20 instruments for each of 3 lipid fractions, but combined there are 30 unique SNPs, then we need to extract each of the 30 SNPs from each lipid fraction (exposure). 


```{r eval=FALSE}
exposure_dat <- mv_extract_exposures(id_exposure)
```

Next, also extract those SNPs from the outcome.

```{r eval=FALSE}
outcome_dat <- extract_outcome_data(exposure_dat$SNP, id_outcome)
```

Once the data has been obtained, harmonise so that all are on the same reference allele.

```{r eval=FALSE}
mvdat <- mv_harmonise_data(exposure_dat, outcome_dat)
```

Finally, perform the multivariable MR analysis

```{r eval=FALSE}
res <- mv_multiple(mvdat)
```

This generates a table of results.

### Note about MV methods

There are several different ways in which this analysis can be formulated. e.g. consider 3 exposures against one outcome, one could:

1. Fit all exposures together or fit one exposure at a time against the residuals of the outcome that has been adjusted for the other outcomes. The former is recommended by default in this R package through the `mv_multiple` function but the latter was how MV MR was originally described by Burgess et al 2015 and can be done with `mv_residual`.
2. Fitting all instruments for all exposures (default) or only fitting the instruments for each exposure sequentially
3. Forcing the slopes through the origin (default) or allowing an intercept term.

With these three different parameters there are eight different ways to do MV analysis. We recommend the default settings as described above.

### Note about visualisation

Plots can be generated using the `plots=TRUE` argument for `mv_multiple` and `mv_residual`. 

The current plots being generated are not necessarily adequate because while they show the slope through the raw points, they do not demonstrate that the raw points might be effectively different between plots because they are conditional on the other exposures. 


* * *

## MR estimates when instruments are correlated

In the examples shown so far it is assumed that instruments are independent (i.e. they are not in linkage disequilibrium, LD). This is to avoid 'double counting' effects. An alternative approach is to estimate the MR effects accounting for the correlation between variants.

The TwoSampleMR package has not implemented this yet, but the [MendelianRandomization](https://cran.r-project.org/web/packages/MendelianRandomization/index.html) R package by Olena Yavorska and Stephen Burgess does have this functionality. We can use the TwoSampleMR package to extract, format and harmonise data, and then convert to the format required by the MendelianRandomization package. The MR-Base server has the individual level genetic data for ~500 Europeans in 1000 genomes data, and can obtain the LD matrix for a set of SNPs using these data. For example:


```{r eval=FALSE}
snplist <- c("rs234", "rs1205")
ld_matrix(snplist)
```

Here `ld_matrix` returns the LD correlation values (not R^2) for each pair of variants present in the 1000 genomes data set.

```{r eval=FALSE}
dat <- harmonise_data(
	exposure_dat = bmi_exp_dat, 
	outcome_dat = chd_out_dat
)
```

Convert to the `MRInput` format for the MendelianRandomization package:

```{r eval=FALSE}
dat2 <- dat_to_MRInput(dat)
```

This produces a list of `MRInput` objects that can be used with the MendelianRandomization functions, e.g.

```{r eval=FALSE}
MendelianRandomization::mr_ivw(dat2[[1]])
```

Alternatively, convert to the `MRInput` format but also obtaining the LD matrix for the instruments

```{r eval=FALSE}
dat2 <- dat_to_MRInput(dat, get_correlation=TRUE)
MendelianRandomization::mr_ivw(dat2[[1]], correl=TRUE)
```

* * *

## MR-MoE: Using a mixture of experts machine learning approach

We recently developed MR-MoE, a method to choose the most appropriate amongst several MR tests using a machine learning algorithm. Note that the method is still under review, but full details are described here: [biorxiv.org/content/early/2017/08/23/173682](http://www.biorxiv.org/content/early/2017/08/23/173682).

MR-MoE operates by taking a set of harmonised data, inferring some characteristics about the dataset, and using those characteristics to predict how well each of the different MR methods will perform on the dataset, in terms of maximising power while minimising false discovery rates. 

In order to run the analysis you must download an RData object that contains the trained random forests that are used to predict the efficacy of each method. This can be downloaded from here:

[dropbox.com/s/5la7y38od95swcf/rf.rdata?dl=0](https://www.dropbox.com/s/5la7y38od95swcf/rf.rdata?dl=0)

**Caution: this is a large file (approx 3Gb)**

Once downloaded, read in the object and use the `mr_moe` function to perform the analysis. An example is shown here, estimating the causal effect of BMI on coronary heart disease:

```{r eval=FALSE}
# Extact instruments for BMI
expsure_dat <- extract_instruments(2)

# Get corresponding effects for CHD
outcome_dat <- extract_outcome_data(exposure_dat$SNP, 7)

# Harmonise
dat <- harmonise_data(exposure_dat, outcome_dat)

# Load the downloaded RData object. This loads the rf object
load("rf.rdata")

# Obtain estimates from all methods, and generate data metrics
res <- mr_wrapper(dat)

# MR-MoE - predict the performance of each method
res_moe <- mr_moe(res, rf)
```



The function does the following:

1. Performs MR using each of 11 MR methods
2. Applies Steiger filtering or heterogeneity filtering or both to remove SNPs that do not have substantially larger R^2 with the exposure than the outcome. Note - for binary traits ensure number of cases, number of controls, and allele frequencies are available for each SNP. For continuous traits make sure the p-value and sample size is available. The function infers if a trait is binary or continuous based on the units.exposure and units.outcome columns - binary traits must have those values set to 'log odds'
3. Performs the 14 MR methods again but using the subset of SNPs that survive Steiger filtering
4. Generates meta data about the summary data to predict the most reliable of the 28 methods applied.

For every exposure / outcome combination in the `dat` object, the MR-MoE method is applied. The function returns a list which is as long as the number of exposure / outcome combinations. In this case, it will be of length 1, containing the result for BMI on CHD.

The result object itself is a list with the following elements:

- `estimates` (results from each MR)
- `heterogeneity` (results from heterogeneity for different filtering approaches)
- `directional_pleiotropy` (egger intercepts)
- `info` (metrics used to generate MOE)

Looking at the `estimates`, we see that there is a column called `MOE` which is the predicted AUROC curve performance of each method. 

* * * 

# Post MR results management 

The TwoSampleMR package also provides the following functions for managing or editing MR results.

## Split outcome names

The outcome column in the output of mr() combines the original outcome name with the outcome trait ID. 

```{r }
head(res)
```

The outcome column can be split into separate columns for the id and outcome name using the split_outcome function:

```{r }
res<-mr(dat)
split_outcome(res)
```

## Split exposure names

Similarly to the outcome column, the exposure column in the output of mr() combines the original exposure name with the exposure trait ID. This can be split into separate columns for the id and exposure name using the split_exposure function. 


## Generate odds ratios with 95% confidence intervals

Users can convert log odds ratios into odds ratios with 95% confidence intervals using: 

```{r }
generate_odds_ratios(res)
```

## Subset on method 

It is sometimes useful to subset results on MR method, so that there is one unique result for each exposure-outcome combination: 

```{r }
subset_on_method(res)
```

The default is to subset on the IVW method when >1 SNP is available and to use the Wald ratio method when a single SNP is available. Users can specify which multi-SNP method to subset on. 

## Combine all results 

It is often useful to combine all results and study level characterists into a single dataframe or table, e.g. for sharing results with collaborators or when the user wishes to present all results in a single table or figure. This can be done using the combine_all_mrresults() function:

```{r }
res<-mr(dat)
het<-mr_heterogeneity(dat)
plt<-mr_pleiotropy_test(dat)
sin<-mr_singlesnp(dat)
all_res<-combine_all_mrresults(res,het,plt,sin,ao_slc=T,Exp=T,split.exposure=F,split.outcome=T)
head(all_res[,c("Method","outcome","exposure","nsnp","b","se","pval","intercept","intercept_se","intercept_pval","Q","Q_df","Q_pval","consortium","ncase","ncontrol","pmid","population")])
```

This combines all results from mr(), mr_heterogeneity(), mr_pleiotropy_test() and mr_singlesnp() into a single dataframe. It also merges the results with outcome study level characteristics from the available_outcomes() function, including sample size characteristics. If requested, it also exponentiates results (e.g. if the user wants log odds ratio converted into odds ratios with 95 percent confidence intervals). 

# References

<br/>
